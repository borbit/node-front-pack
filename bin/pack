#!/usr/bin/env node

/**
 * TODO:
 * 1) images.json should be placed to a dist dir.
 */

/**
 * Module dependencies.
 */
var package = require('../package.json')
  , sprintf = require('sprintf').sprintf
  , program = require('commander')
  , rimraf = require('rimraf')
  , crypto = require('crypto')
  , async = require('async')
  , path = require('path')
  , _ = require('lodash')
  , fs = require('fs');

var utils = require('../lib/utils');

/**
 * CLI
 */
program
  .version(package.version)
  .usage('[options] [pages]')
  .option('-v, --verbose'    , 'verbose output')
  .option('-m, --mark'       , 'add checksum to processed file names')
  .option('-i, --images'     , 'include all blocks\' images into the package')
  .option('-s, --sprites'    , 'build sprites and include them into the package')
  .option('-e, --optimize'   , 'optimize images included into the package')
  .option('-o, --out <path>' , 'package output dir')
  .parse(process.argv);

var cwd = process.cwd();

/**
 * Config
 */
try {
  var cfg = require(path.join(cwd, '/config'));
} catch (err) {
  console.error(" error: cannot find config file");
  process.exit(1);
}

// green tick symbol
var tick = '\033[32mâœ“\033[39m';

// short cut for the utils.log
var log = utils.log;

// short cut for the utils.falog
var falog = utils.falog;

/**
 * Pack
 */
(function() {
  var ver = Date.now().toString();
  var tmpDir = path.join(cfg.TEMPS_ROOT, ver);
  var outDir = path.join(cfg.DISTS_ROOT, ver);
  
  // Explicitly set output dir
  if (program.output) {
    outDir = program.output;
  }

  var scope = {
    tmpDir: tmpDir
  , outDir: outDir
  , cfg: cfg
  };

  var stack = [];

  stack.push(function(scope, cb) {
    fs.mkdir(tmpDir, function(err, pages) {
      if (err) return cb(err);
      log(' %s created temp directory \t\t \033[90m%s\033[39m', tick, tmpDir);
      cb();
    });
  });

  stack.push(require('../lib/mw-build'));

  if (program.mark) {
    stack.push(function(scope, cb) {
      markAssets(scope.assetsMap, function(err, assetsMap) {
        if (err) return cb(err);
        log(' %s marked assets with md5 checksum', tick);
        scope.assetsMap = assetsMap;
        cb();
      });
    });
  }

  if (program.images) {
    stack.push(require('../lib/mw-images'));
  }
  if (program.images && program.optimize) {
    stack.push(require('../lib/mw-optimize'));
  }

  stack.push(function(scope, cb) {
    gzipAssets(scope.assetsMap, function(err, rate) {
      if (err) return cb(err);
      log(' %s gzipped all gzippable \t\t \033[90m%s%\033[39m', tick, rate);
      cb();
    });
  });

  stack.push(function(scope, cb) {
    createAssetsMapFile(scope.assetsMap, outDir, function(err) {
      if (err) return cb(err);
      log(' %s created assets map file \t\t \033[90m%s\033[39m', tick, cfg.ASSETS_MAP_FILE);
      cb();
    });
  });

  stack.push(function(scope, cb) {
    updateDistVersion(ver, function(err) {
      if (err) return cb(err);
      log(' %s created "latest version" file \t \033[90m%s\033[39m', tick, cfg.VERSION_FILE);
      cb();
    });
  });

  stack.push(function(scope, cb) {
    fs.mkdir(outDir, function(err) {
      if (err) return cb(err);
      log(' %s created dist directory \t\t \033[90m%s\033[39m', tick, outDir);
      cb();
    });
  });

  stack.push(function(scope, cb) {
    moveFilesToDist(tmpDir, outDir, function(err) {
      if (err) return cb(err);
      log(' %s moved files to the dist directory \t \033[90m%s\033[39m', tick, outDir);
      cb();
    });
  });

  stack.push(function(scope, cb) {
    removeDir(tmpDir, function(err) {
      if (err) return cb(err);
      log(' %s removed tmp directory  \t\t \033[90m%s\033[39m', tick, tmpDir);
      cb();
    });
  });
  
  async.forEachSeries(stack, function(mw, cb) {
    mw(scope, cb);
  }, function(err) {
    if (err) {
      console.error(' error: %s', err.message);
      process.exit(1);
    }
    log(' done!');
  });
})();

/*
 *
 */
function createAssetsMapFile(assetsMap, distDir, cb) {
  var map = {};

  _.each(assetsMap, function(assets, page) {
    var css = {}, js = {};

    _.each(assets.css, function(asset, group) {
      css[group] = path.basename(asset);
    });
    _.each(assets.js, function(asset, group) {
      js[group] = path.basename(asset);
    });

    map[page] = {};

    if (_.size(css))
      map[page].css = css;
    if (_.size(js))
      map[page].js = js;
  });

  // TODO: Tmp solution for moving assets map file out of site_media dir
  fs.writeFile(cfg.ASSETS_MAP_FILE, JSON.stringify(map), cb);
}

/*
 *
 */
function gzip(from, to, cb) {
  var zlib = require('zlib');

  async.waterfall([
    function(cb) {
      utils.readFile(from, cb);
    },
    function(cont, cb) {
      zlib.gzip(cont, cb)
    },
    function(cont, cb) {
      utils.writeFile(to, cont, cb);
    }
  ], cb);
}

/*
 *
 */
function removeDir(path, cb) {
  rimraf(path, cb);
}

/*
 *
 */
function updateDistVersion(version, cb) {
  fs.writeFile(cfg.VERSION_FILE, JSON.stringify(version), cb);
}

/*
 *
 */
function moveFilesToDist(tempDir, distDir, cb) {
  async.waterfall([
    function(cb) {
      fs.readdir(tempDir, cb);
    },
    function(files, cb) {
      async.forEach(files, function(file, cb) {
        fs.rename(
          path.join(tempDir, file)
        , path.join(distDir, file)
        , cb);
      }, cb);
    }
  ], cb)
}

/**
 *
 */
function markAssets(map, cb) {
  var marked = {};

  utils.eachAsset(map, function(filePath, p, cb) {
    utils.markFile(filePath, function(err, newPath) {
      if (err) return cb(err);

      var inpage = marked[p.page] || (marked[p.page] = {});
      var ingroup = inpage[p.group] || (inpage[p.group] = {});
      ingroup[p.asset] = newPath;

      cb();
    });
  }, function(err) {
    if (err) return cb(err);
    cb(null, marked);
  });
}

/**
 *
 */
function gzipAssets(assetsMap, cb) {
  var oldTotalSize = 0;
  var newTotalSize = 0;
  
  utils.eachAsset(assetsMap, function(filePath, p, cb) {
    var gzPath = filePath + '.gz';

    fs.stat(filePath, function(err, oldStat) {
      if (err) return cb(err);
      
      gzip(filePath, gzPath, function(err, newStat) {
        if (err) return cb(err);

        oldTotalSize += oldStat.size;
        newTotalSize += newStat.size;
        cb();
      });
    });
  }, function(err) {
    if (err) return cb(err);
    cb(null, 100 - ~~(newTotalSize / (oldTotalSize / 100)));
  });
}