#!/usr/bin/env node

/**
 * Module dependencies.
 */
var package = require('../package.json')
  , sprintf = require('sprintf').sprintf
  , program = require('commander')
  , rimraf = require('rimraf')
  , crypto = require('crypto')
  , async = require('async')
  , path = require('path')
  , _ = require('lodash')
  , fs = require('fs');

/**
 * CLI
 */
program
  .version(package.version)
  .usage('[options] [pages]')
  .option('-v, --verbose'    , 'verbose output')
  .option('-m, --mark'       , 'add checksum to processed file names')
  .option('-i, --images'     , 'include all blocks\' images into the package')
  .option('-s, --sprites'    , 'build sprites and include them into the package')
  .option('-e, --optimize'   , 'optimize images included into the package')
  .option('-o, --out <path>' , 'package output dir')
  .parse(process.argv);

var cwd = process.cwd();

/**
 * Config
 */
try {
  var cfg = require(path.join(cwd, '/config'));
} catch (err) {
  console.error(" error: cannot find config file");
  process.exit(1);
}

var tick = '\033[32m✓\033[39m';

/**
 * Pack
 */
(function() {
  var ver = Date.now().toString();
  var tmpDir = path.join(cfg.TEMPS_ROOT, ver);
  var outDir = path.join(cfg.DISTS_ROOT, ver);
  
  // Explicitly set output dir
  if (program.output) {
    outDir = program.output;
  }

  var assetsMap;
  var imagesMap;
  
  async.waterfall([
    function(cb) {
      createDir(tmpDir, cb);
    },
    function(cb) {
      log(' %s created temp directory \t\t \033[90m%s\033[39m', tick, tmpDir);
      getPagesToPack(program.args, cb);
    },
    function(pages, cb) {
      buildPagesDist(pages, tmpDir, cb);
    },
    function(map, cb) {
      assetsMap = map;

      // Don't do anything if "mark" feature is not turned on.
      // Temporrary solution, to experiment with it first.
      if (!program.mark) {
        return cb(null, null);
      }

      markAssets(assetsMap, cb);
    },
    function(map, cb) {
      // Do it only if the "mark" feature is turned on.
      // Temporrary solution, to experiment with it first.
      if (program.mark) {
        log(' %s marked assets with md5 checksum', tick);
        assetsMap = map;
      }

      // Don't do anything if "images" feature is not turned on.
      // Temporrary solution, to experiment with it first.
      if (!program.images) {
        return cb(null, null);
      }
      
      gatherImages(cfg.STATIC_ROOT, tmpDir, cb);
    },
    function(map, cb) {
      // Don't do anything if "images" feature is not turned on.
      // Temporrary solution, to experiment with it first.
      if (!program.images) {
        return cb(null, null);
      }

      log(' %s gathered all existing images', tick);

      imagesMap = map;
      optimizeJPEG(tmpDir, imagesMap, cb);
    },
    function(rate, cb) {
      // Don't do anything if "images" feature is not turned on.
      // Temporrary solution, to experiment with it first.
      if (!program.images) {
        return cb();
      }

      log(' %s optimized JPEG images with jpegtran  \t\t \033[90m%s%\033[39m', tick, rate);

      applyImagesMap(assetsMap, imagesMap, cb);
    },
    function(cb) {
      // Do it only if the "images" feature is turned on.
      // Temporrary solution, to experiment with it first.
      if (program.images) {
        log(' %s applyed gathered images to assets', tick);
      }

      gzipAssets(assetsMap, cb);
    },
    function(rate, cb) {
      log(' %s gzipped all gzippable \t\t \033[90m%s%\033[39m', tick, rate);

      // Don't do anything if "images" feature is not turned on.
      // Temporrary solution, to experiment with it first.
      if (!program.images) {
        return cb();
      }

      createImagesMapFile(imagesMap, outDir, cb);
    },
    function(cb) {
      // Do it only if the "images" feature is turned on.
      // Temporrary solution, to experiment with it first.
      if (program.images) {
        log(' %s created images map file \t\t \033[90m%s\033[39m', tick, cfg.IMAGES_MAP_FILE);
      }

      createAssetsMapFile(assetsMap, outDir, cb);
    },
    function(cb) {
      log(' %s created assets map file \t\t \033[90m%s\033[39m', tick, cfg.ASSETS_MAP_FILE);
      updateDistVersion(ver, cb);
    },
    function(cb) {
      log(' %s created "latest version" file \t \033[90m%s\033[39m', tick, cfg.VERSION_FILE);
      createDir(outDir, cb);
    },
    function(cb) {
      log(' %s created dist directory \t\t \033[90m%s\033[39m', tick, outDir);
      moveFilesToDist(tmpDir, outDir, cb);
    },
    function(cb) {
      log(' %s moved files to the dist directory \t \033[90m%s\033[39m', tick, outDir);
      removeDir(tmpDir, cb);
    }
  ], function(err) {
    if (err) {
      console.error(' error: %s', err.message);
      process.exit(1);
    }

    log(' %s removed tmp directory  \t\t \033[90m%s\033[39m', tick, tmpDir);
    log(' done!');
  });

})();

/*
 *
 */
function buildPageDist(page, groups, dir, cb) {
  log(' packing %s:', page);

  var res = {css: {}, js: {}};

  async.series([
    function(cb) {
      async.forEachSeries(groups.css, function(group, cb) {
        log('  css %s', group);
        buildCssDist(page, group, dir, function(err, files) {
          if (err) return cb(err);
          if (files.length) res.css[group] = files;
          cb();
        });
      }, cb);
    },
    function(cb) {
      async.forEachSeries(groups.js, function(group, cb) {
        log('  js %s', group);
        buildJSDist(page, group, dir, function(err, files) {
          if (err) return cb(err);
          if (files.length) res.js[group] = files;
          cb();
        });
      }, cb);
    }
  ], function(err) {
    if (err) return cb(err);
    cb(null, res);
  });
}

/*
 *
 */
function buildPagesDist(pages, dir, cb) {
  var map = {};
  var groups = {
    css : ['base', 'ie7', 'ie8', 'ie9'],
    js  : ['base', 'ie7', 'ie8', 'ie9']
  };

  async.forEachSeries(pages, function(page, cb) {
    buildPageDist(page, groups, dir, function(err, files) {
      map[page] = files;
      cb(err);
    });
  }, function(err) {
    if (err) return cb(err);
    cb(null, map);
  });
}

/*
 *
 */
function buildCssDist(page, group, dir, cb) {
  var srcs = getSources(page)
    , csses = srcs['css_' + group]
    , lesses = srcs['less_' + group];

  if ((!csses || !csses.length) &&
      (!lesses || !lesses.length)) {
    log('   \033[90m✘ nothing to build here\033[39m');
    return cb(null, []);
  }

  var dist = path.join(dir, sprintf('%s.%s.css', page, group));

  async.waterfall([
    function(cb) {
      collectCss(csses, dist, cb);
    },
    function(stat, cb) {
      stat && falog('concatted *.css files\t\t', stat);
      compileLess(lesses, srcs.includes, dist, cb);
    },
    function(stat, cb) {
      stat && falog('compiled *.less files\t\t', stat);
      buildSprites(dist, cb);
    },
    function(stat, cb) {
      stat && falog('built sprites with Tailor\t\t', stat);
      optimizeCSS(dist, cb);
    },
    function(stat, cb) {
      stat && falog('optimized with CSSO\t\t', stat);
      embedBase64(dist, cb);
    },
    function(stat, cb) {
      stat && falog('embedded images and asset hosts\t', stat);
      cb(null, dist);
    }
  ], cb);
}

/*
 *
 */
function buildJSDist(page, group, dir, cb) {
  var srcs = getSources(page);
  var jses = srcs['js_' + group];

  if (!jses || !jses.length) {
    log('   \033[90m✘ nothing to build here\033[39m');
    return cb(null, []);
  }

  var dist = path.join(dir, sprintf('%s.%s.js', page, group));

  async.waterfall([
    function(cb) {
      collectJS(jses, dist, cb);
    },
    function(stat, cb) {
      falog('concatted *.js files\t\t', stat);
      compressJS(dist, cb);
    },
    function(stat, cb) {
      falog('compressed with UglifyJS\t\t', stat);
      cb(null, dist);
    }
  ], cb);
}

/*
 *
 */
function createAssetsMapFile(assetsMap, distDir, cb) {
  var map = {};

  _.each(assetsMap, function(assets, page) {
    var css = {}, js = {};

    _.each(assets.css, function(asset, group) {
      css[group] = path.basename(asset);
    });
    _.each(assets.js, function(asset, group) {
      js[group] = path.basename(asset);
    });

    map[page] = {};

    if (_.size(css))
      map[page].css = css;
    if (_.size(js))
      map[page].js = js;
  });

  // TODO: Tmp solution for moving assets map file out of site_media dir
  fs.writeFile(cfg.ASSETS_MAP_FILE, JSON.stringify(map), cb);
}

/*
 *
 */
function createImagesMapFile(imagesMap, distDir, cb) {
  // TODO: Tmp solution for moving images map file out of site_media dir
  fs.writeFile(cfg.IMAGES_MAP_FILE, JSON.stringify(imagesMap), cb);
}

/*
 *
 */
function collectJS(files, dist, cb) {
  files = _.map(files, function(file) {
    return cfg.STATIC_ROOT + '/' + file;
  });

  async.waterfall([
    function(cb) {
      concatFiles(files, cb);
    },
    function(css, cb) {
      appendFile(dist, css, cb);
    }
  ], cb);
}

/*
 *
 */
function compressJS(file, cb) {
  var jsp = require("uglify-js").parser;
  var pro = require("uglify-js").uglify;

  async.waterfall([
    function(cb) {
      readFile(file, cb);
    },
    function(cont, cb) {
      var ast = jsp.parse(cont);
      
      ast = pro.ast_mangle(ast);
      ast = pro.ast_squeeze(ast);

      writeFile(file, pro.gen_code(ast), cb);
    }
  ], cb);
}

/*
 *
 */
function collectCss(files, dist, cb) {
  if (!files || !files.length) {
    return cb(null, null);
  }
  
  files = _.map(files, function(file) {
    return cfg.STATIC_ROOT + '/' + file;
  });

  async.waterfall([
    function(cb) {
      concatFiles(files, cb);
    },
    function(css, cb) {
      appendFile(dist, css, cb);
    }
  ], cb);
}

/*
 *
 */
function compileLess(lesses, inclds, dist, cb) {
  if (!lesses || !lesses.length)
    return cb(null, null);

  var dir = cfg.STATIC_ROOT + '/';
  var files = [];
  
  files = files.concat(inclds || []);
  files = files.concat(lesses);

  var less = require('less');

  async.waterfall([
    function(cb) {
      // Cancat all less files before rendering and patch
      // all the image urls to be relative to the static dir
      async.concatSeries(files, function(file, cb) {
        readFile(dir + file, function(err, cont) {
          if (err) return cb(err);
          var sub = 'background-image: url("';
          var rep = 'background-image: url("' + path.dirname(file) + '/';
          cb(null, cont.split(sub).join(rep));
        });
      }, cb);
    },
    function(cont, cb) {
      less.render(cont.join(''), cb);
    },
    function(css, cb) {
      appendFile(dist, css, cb);
    }
  ], cb);
}

/*
 *
 */
function optimizeCSS(file, cb) {
  var ccso = require('csso');

  async.waterfall([
    function(cb) {
      readFile(file, cb);
    },
    function(cont, cb) {
      writeFile(file, ccso.justDoIt(cont), cb);
    }
  ], cb);
}

/*
 *
 */
function buildSprites(file, cb) {
  var tailor = require('tailor');

  tailor([file], {
    outDirPath: path.dirname(file)
  , rootDirPath: cfg.STATIC_ROOT
  }, function(err, files) {
    if (err) return cb(err);
    if (files[0].length == 1) {
      return cb(null, null);
    }
    fs.stat(file, cb);
  });
}

/*
 *
 */
function embedBase64(file, cb) {
  var enhance;
  enhance = require('enhance-css');
  enhance = new enhance({
    assetHosts: cfg.ASSETS_HOSTS
  , rootPath: cfg.STATIC_ROOT
  , stamp: false
  });

  async.waterfall([
    function(cb) {
      readFile(file, cb);
    },
    function(cont, cb) {
      enhance.process(cont, cb)
    },
    function(cont, cb) {
      writeFile(file, cont.embedded.plain, cb);
    }
  ], cb);
}

/*
 *
 */
function gzip(from, to, cb) {
  var zlib = require('zlib');

  async.waterfall([
    function(cb) {
      readFile(from, cb);
    },
    function(cont, cb) {
      zlib.gzip(cont, cb)
    },
    function(cont, cb) {
      writeFile(to, cont, cb);
    }
  ], cb);
}

/*
 * Renames file adding md5 checksum of its content.
 * Passes new name to the callback function.
 * 
 * @param filePath string
 * @param outDirPath string (optional)
 * @param cb fucntion
 */
function markFile(filePath, outDirPath, cb) {
  // if outDirPath is not provided
  if (!cb) {
    cb = outDirPath;
    outDirPath = null;
  }

  readFile(filePath, function(err, cont) {
    if (err) return cb(err);

    var fileName = path.basename(filePath);
    var md5 = crypto.createHash('md5');
    md5 = md5.update(cont);
    md5 = md5.digest('hex');

    var chunks = fileName.split('.');
    var mark = md5.substr(0, 15);
    
    chunks.splice(chunks.length-1, 0, mark);

    var newName = chunks.join('.');

    if (outDirPath) {
      var newPath = path.join(outDirPath, newName);
      var rStream = fs.createReadStream(filePath);
      var wStream = fs.createWriteStream(newPath);
      rStream.pipe(wStream);
      rStream.on('end', function(err) {
        if (err) return cb(err);
        cb(null, newPath);
      });
    } else {
      var dirPath = path.dirname(filePath);
      var newPath = path.join(dirPath, newName);

      fs.rename(filePath, newPath, function(err) {
        if (err) return cb(err);
        cb(null, newPath);
      });
    }
  });
}

/*
 *
 */
function readFile(filePath, cb) {
  fs.readFile(filePath, 'utf8', cb);
}

/*
 *
 */
function writeFile(file, cont, cb) {
  async.waterfall([
    function(cb) {
      fs.writeFile(file, cont, cb);
    },
    function(cb) {
      fs.stat(file, cb);
    }
  ], cb);
}

/*
 *
 */
function appendFile(file, cont, cb) {
  async.waterfall([
    function(cb) {
      fs.appendFile(file, cont, cb);
    },
    function(cb) {
      fs.stat(file, cb);
    }
  ], cb);
}

/*
 *
 */
function concatFiles(files, each, cb) {
  if (!cb) {
    cb = each;
    each = null;
  }

  async.concatSeries(files, readFile, function(err, res) {
    if (err) return cb(err);
    cb(null, res.join(''));
  });
}

/*
 *
 */
function createDir(path, cb) {
  fs.exists(path, function(exists) {
    if (exists) return cb();
    fs.mkdir(path, cb);
  });
}

/*
 *
 */
function removeDir(path, cb) {
  rimraf(path, cb);
}

/*
 *
 */
function createFiles(files, cb) {
  async.forEachSeries(files, function(file, cb) {
    fs.writeFile(file, '', cb);
  }, cb);
}

/*
 *
 */
function getSources(name) {
  if (name == 'cmn') {
    return require(getCmnSrcsPath()); 
  } else {
    return _.extend({}, require(getPageSrcsPath(name)),
      _.pick(require(getCmnSrcsPath()), 'includes'));
  }
}

/*
 *
 */
function getPageDirPath(name) {
  return sprintf('%s/%s', cfg.PAGES_ROOT, name);
}

/*
 *
 */
function getPageTmplPath(name) {
  return sprintf('%s/%2$s/%2$s.html', cfg.PAGES_ROOT, name);
}

/*
 *
 */
function getPageSrcsPath(name) {
  return sprintf('%s/%2$s/%2$s.json', cfg.PAGES_ROOT, name);
}

/*
 *
 */
function getCmnSrcsPath() {
  return sprintf('%s/cmn.json', cfg.PAGES_ROOT);
}

/*
 *
 */
function updateDistVersion(version, cb) {
  fs.writeFile(cfg.VERSION_FILE, JSON.stringify(version), cb);
}

/*
 *
 */
function moveFilesToDist(tempDir, distDir, cb) {
  async.waterfall([
    function(cb) {
      fs.readdir(tempDir, cb);
    },
    function(files, cb) {
      async.forEach(files, function(file, cb) {
        fs.rename(
          path.join(tempDir, file)
        , path.join(distDir, file)
        , cb);
      }, cb);
    }
  ], cb)
}

/**
 * Looks through the pages directory and
 * returns names list of existing pages
 * 
 * @param cb function
 */
function getExistingPages(cb) {
  async.waterfall([
    function(cb) {
      fs.readdir(cfg.PAGES_ROOT, cb);
    },
    function(files, cb) {
      var pages = [];

      async.forEach(files, function(file, cb) {
        fs.stat(path.join(cfg.PAGES_ROOT, file), function(err, stat) {
          if (err) return cb(err);
          if (stat.isDirectory()) {
            pages.push(file);
          }
          cb();
        });
      }, function(err) {
        if (err) return cb(err);
        cb(null, pages);
      });
    }
  ], cb);
}

/**
 * Returns names list of pages to pack basing on the existing
 * pages and pages names passed through the first argument, returns
 * error of at least one of passed pages is not exist. Addes "cmn"
 * page to the list if particular pages are not passed.
 *
 * @param cb function
 */
function getPagesToPack(pages, cb) {
  getExistingPages(function(err, existing) {
    if (err) return cb(err);
    if (pages.length) {
      _.each(pages, function(page) {
        if (!~existing.indexOf(page)) {
          cb(new Error('cannot find page ' + page));
          return false;
        }
      });
    } else {
      pages = existing.concat('cmn');
    }
    cb(null, pages);
  });
}

/*
 *
 */
function gatherImages(dirPath, outDirPath, cb) {
  findImages(dirPath, function(err, list) {
    if (err) return cb(err);

    var map = {};

    async.forEach(list, function(imgPath, cb) {
      markFile(imgPath, outDirPath, function(err, newPath) {
        if (err) return cb(err);

        var orgImgUrl = imgPath.replace(dirPath + '/', '');
        var newImgUrl = newPath.replace(outDirPath + '/', '');
        map[orgImgUrl] = newImgUrl;
        cb();
      });
    }, function(err) {
      if (err) return cb(err);
      cb(null, map);
    });
  });
}

/*
 *
 */
function optimizePNG(dirPath, imagesMap, cb) {
  var execFile = require('child_process').execFile;
  var oldSize = 0;

  var files = _.map(imagesMap, function(fileName) {
    return path.join(dirPath, fileName);
  });
  files = _.filter(files, function(filePath) {
    return ~filePath.indexOf('.png');
  });

  async.waterfall([
    function(cb) {
      sumFilesSize(files, cb);
    },
    function(size, cb) {
      oldSize = size;
      execFile('optipng', ['-o7'].concat(filesPng), {
        maxBuffer: Infinity
      }, cb);
    },
    function(so, se, cb) {
      sumFilesSize(files, cb);
    }
  ], function(err, newSize) {
    if (err) return cb(err);
    cb(null, 100 - ~~(newSize / (oldSize / 100)));
  });
}

/*
 *
 */
function optimizeJPEG(dirPath, imagesMap, cb) {
  var execFile = require('child_process').execFile;
  var oldSize = 0;

  var files = _.map(imagesMap, function(fileName) {
    return path.join(dirPath, fileName);
  });
  files = _.filter(files, function(filePath) {
    return ~filePath.indexOf('.jpg') ||
           ~filePath.indexOf('.jpeg');
  });

  async.waterfall([
    function(cb) {
      sumFilesSize(files, cb);
    },
    function(size, cb) {
      oldSize = size;

      async.forEachSeries(files, function(filePath, cb) {
        var args = [
          '-optimize'
        , '-copy', 'none'
        , '-outfile', filePath
        , filePath
        ];
        execFile('jpegtran', args, cb);
      }, cb);
    },
    function(cb) {
      sumFilesSize(files, cb);
    }
  ], function(err, newSize) {
    if (err) return cb(err);
    cb(null, 100 - ~~(newSize / (oldSize / 100)));
  });
}

/*
 *
 */
function sumFilesSize(filesPath, cb) {
  async.reduce(filesPath, 0, function(size, filePath, cb) {
    fs.stat(filePath, function(err, stat) {
      if (err) return cb(err);
      cb(null, size + stat.size);
    });
  }, cb);
}

/*
 *
 */
function applyImagesMap(assetsMap, imagesMap, cb) {
  eachAsset(assetsMap, function(filePath, p, cb) {
    readFile(filePath, function(err, content) {
      if (err) return cb(err);

      _.each(imagesMap, function(newUrl, orgUrl) {
        content = content.split(orgUrl).join(newUrl);
      });
      
      writeFile(filePath, content, cb);
    });
  }, cb);
}

/*
 *
 */
function findImages(dirPath, cb) {
  fs.readdir(dirPath, function(err, list) {
    if (err) return cb(err);

    var images = _.filter(list, function(fileName) {
      return ~fileName.indexOf('.jpg')
          || ~fileName.indexOf('.jpeg')
          || ~fileName.indexOf('.webp') //soon
          || ~fileName.indexOf('.png')
          || ~fileName.indexOf('.gif');
    });

    images = _.map(images, function(fileName) {
      return path.join(dirPath, fileName);
    });

    filterDirs(list, dirPath, function(dirs) {
      dirs = _.map(dirs, function(dirName) {
        return path.join(dirPath, dirName);
      });

      async.concat(dirs, findImages, function(err, other) {
        if (err) return cb(err);
        cb(null, images.concat(other));
      });
    });
  });
}

/**
 *
 */
function markAssets(map, cb) {
  var marked = {};

  eachAsset(map, function(filePath, p, cb) {
    markFile(filePath, function(err, newPath) {
      if (err) return cb(err);

      var inpage = marked[p.page] || (marked[p.page] = {});
      var ingroup = inpage[p.group] || (inpage[p.group] = {});
      ingroup[p.asset] = newPath;

      cb();
    });
  }, function(err) {
    if (err) return cb(err);
    cb(null, marked);
  });
}

/**
 *
 */
function gzipAssets(assetsMap, cb) {
  var oldTotalSize = 0;
  var newTotalSize = 0;
  
  eachAsset(assetsMap, function(filePath, p, cb) {
    var gzPath = filePath + '.gz';

    fs.stat(filePath, function(err, oldStat) {
      if (err) return cb(err);
      
      gzip(filePath, gzPath, function(err, newStat) {
        if (err) return cb(err);

        oldTotalSize += oldStat.size;
        newTotalSize += newStat.size;
        cb();
      });
    });
  }, function(err) {
    if (err) return cb(err);
    cb(null, 100 - ~~(newTotalSize / (oldTotalSize / 100)));
  });
}

/**
 *
 */
function filterDirs(list, rootPath, cb) {
  async.filter(list, function(fileName, cb) {
    var filePath = path.join(rootPath, fileName);

    fs.stat(filePath, function(err, stat) {
      if (err) return cb(err);
      cb(stat.isDirectory());
    });
  }, cb);
}

/**
 *
 */
function eachAsset(map, iter, cb) {
  var pages = _.keys(map);

  async.forEach(pages, function(page, cb) {
    var groups = _.keys(map[page]);
    var inpage = map[page];

    async.forEach(groups, function(group, cb) {
      var assets = _.keys(inpage[group]);
      var ingroup = inpage[group];

      async.forEach(assets, function(asset, cb) {
        iter(ingroup[asset], {
          page  : page
        , group : group
        , asset : asset
        }, cb);
      }, cb);

    }, cb);
  }, cb);
}

/*
 * Simple log
 */
function log() {
  if (program.verbose) {
    console.log.apply(console, arguments);
  }
}

/*
 * File action log
 */
function falog(msg, stat) {
  log('   %s %s \033[90m%s kb\033[39m', tick, msg, kb(stat.size));
}

/**
 * Returns size value in kilobites
 *
 * @param size integer
 * @return float
 */
function kb(size) {
  return ~~(size / 1024 * 100) / 100;
}